'use strict';

var objectHelpers = require('../reducers/object_helpers');
var stringHelpers = require('../reducers/string_helpers');
var eventManager = require('../utils/event_manager');

/*
 * This module is responsibe for the state used by tabs: WL_STATE.tabs
 * the tab state is generated by the dom elements which are found by the watcher
 * when the watcher finds a tab, it sends the details here to the guard.
 * There is an array (tabs) within which only one named tab can be true at any time
 * the state of said tab is a named object attribute of the <tab_group>
 * This may seem weird to have everything split between individual objects 
 * and an array, but the array is good for in here (looping over an object is a bit complex)
 * and rivets only reads state from an object, unless you're generating that 
 * object from an array, which is normal, except here where we're doing the oposite.
 * so that's tabs!
 * 
 * Example tab group state object: {
		<tab_group_name>: {
			tabs: [ 
				{name: <tab_name>, active: false, type: 'claim', data: {claimObj}}, 
				{name: <tab2_name>, active: false, type: 'something', data: {stuff}} 
			],
			tempTab: { name: <tab_name>, set: false },
			<tab_name>: true,
			<tab2_name>: false,
			current_tab: { //to hold additional into about the current tab
				is_claim_editor: false
			}
		]
	}
*/

var addTabToTabGroup = function(groupName, newTab){
	//newTab = { tabName: <string>, tabType: <string>, data: <obj> }
	//first add the tab to the tab group array
	WL_STATE.tabs[groupName].tabs.push({name: newTab.tabName, active: false, type: newTab.tabType, data: newTab.data});

	//now add the named tab state object for rivets
	WL_STATE.tabs[groupName][newTab.tabName] = false;
}

module.exports = {

	init: function(){
		WL_STATE.tabs = {}
	},

	createTabGroup: function(groupName){
		var checkError = false;

		//first check the name we've been passed is all good
		if (typeof(groupName) != 'string' || groupName == null || groupName == undefined) {
			console.error("There's someting weird about the tab group you're trying to add that tab to: ", WL_STATE.tabs[groupName]);
			checkError = true;
		}

		//check if the tab name has any white space or caps, can't do that with rivets	
		if (stringHelpers.hasWhiteSpace(groupName) || stringHelpers.hasUpperCaseChars(groupName)) {
			console.error("Sorry, tab names cannot have white space or uppercase characters");
			checkError = true;
		}

		//now lets check that the group doesn't already exist
		if (WL_STATE.tabs.hasOwnProperty(groupName)) {
			console.warn("Tab group already exists, not adding");
			checkError = true;
		}

		if (!checkError) {
			//yeay! New tab group!
			console.info('setting new empty tab group');
			WL_STATE.tabs[groupName] = {
				tabs:[], 
				tempTab: {
					name: '',
					set: false,
					active: false,
					type: ''
				},
				current_tab: {
					name: '',
					type: '',
					data: {}
				}
			};
		}
	},

	addTabToTabGroup: function(groupName, newTab){
		//newTab = { tabName: <string>, tabType: <string>, data: <obj> }
		var checkError = false;


		//check if the tab name has any white space or caps, can't do that with rivets	
		if (stringHelpers.hasWhiteSpace(newTab.tabName) || stringHelpers.hasUpperCaseChars(newTab.tabName)) {
			console.error("Sorry, tab names cannot have white space or uppercase characters");
			checkError = true;
		}

		//and check the group name
		if (typeof(groupName) != 'string' || groupName == null || groupName == undefined) {
			console.error("There's someting weird about the tab group you're trying to add that tab to: ", WL_STATE.tabs[groupName]);
			checkError = true;
		}

		//and make sure the group exists and is valid
		if (typeof(WL_STATE.tabs[groupName]) != 'object') {
			console.error("There's something weird about the tab group you're trying to add your tab to: ", WL_STATE.tabs[groupName]);
			checkError = true;
		}

		//and (mainly) check that the tab doesn't already exist in the group
		console.log('tabName: ', newTab.tabName);
		for (var t = 0; t < WL_STATE.tabs[groupName].tabs.length; t++) {
			console.log('against: ', WL_STATE.tabs[groupName].tabs[t].name);
			if (WL_STATE.tabs[groupName].tabs[t].name == newTab.tabName) {
				checkError = true;
				this.activateTab(groupName, newTab.tabName);
				break;
			}
		}

		if (!checkError) {
			//yeay! new tab :) also don't worry about cloning / mutating / applying to the global state, rivets shouldn't be running yet
			addTabToTabGroup(groupName, newTab);
		}
	},

	addTempTabToGroup: function(groupName, newTab){
		//newTab = { tabName: <string>, tabType: <string>, data: <obj> }
		/* Recreates the sublime text tab behaviour(ish). One click adds temp tab, a second adds it permanently 
		 */
		var checkError = false;

		 //first check there isn't a main tab of this name
		 for (var t = 0; t < WL_STATE.tabs[groupName].tabs.length; t++) {
			if (WL_STATE.tabs[groupName].tabs[t].name == newTab.tabName) {
				checkError = true;
				this.activateTab(groupName, newTab.tabName);
				break;
			}
		}
		
		if (!checkError) {
			//if this is already a tempTab, add it to the main group and set it to active
			if (WL_STATE.tabs[groupName].tempTab.name == newTab.tabName) {

				addTabToTabGroup(groupName, newTab);
				this.activateTab(groupName, newTab.tabName);
				WL_STATE.tabs[groupName].tempTab.active = false;
				WL_STATE.tabs[groupName].tempTab.set = false;
				WL_STATE.tabs[groupName].tempTab.type = '';
				WL_STATE.tabs[groupName].tempTab.data = {};

			} else {
				WL_STATE.tabs[groupName].tempTab = {};
				//else, add / replace the old temp tab
				WL_STATE.tabs[groupName].tempTab[newTab.tabName] = true; //rivets trick for identifying special cases - eg the welcome tab
				WL_STATE.tabs[groupName].tempTab.name = newTab.tabName;
				WL_STATE.tabs[groupName].tempTab.set = true;
				WL_STATE.tabs[groupName].tempTab.type = newTab.tabType;
				WL_STATE.tabs[groupName].tempTab.data = newTab.data;
				this.activateTempTab(groupName);
			}
		}
	},

	activateTab: function(groupName, tabToActivate){
		//going to assume the creation process above caught any tab bugs so we can run this afap! giggity
		var newTabGroup = objectHelpers.cloneThisObject(WL_STATE.tabs[groupName]);

		for (var t = 0; t < newTabGroup.tabs.length; t++) {
			//set the tabs array item to false
			newTabGroup.tabs[t].active = false;
			//and set it's named counterpart to false
			newTabGroup[newTabGroup.tabs[t].name] = false;

			if (newTabGroup.tabs[t].name == tabToActivate) {
				//set the tab array item to true - yeay!
				newTabGroup.tabs[t].active = true;
				//and it's named counterpart
				newTabGroup[newTabGroup.tabs[t].name] = true;
				//now fire the event!
				eventManager.fire('tab_opened', newTabGroup.tabs[t]);
			}
		}

		//temp tab will be false
		newTabGroup.tempTab.active = false;

		//add back to state so rivets can render
		WL_STATE.tabs[groupName] = newTabGroup;
	},

	activateTempTab: function(groupName){
		/* Sets the temp tab name to the one passed in
		 * Activates the temp tab
		 */

		//clone the tab group state
		var newTabGroup = objectHelpers.cloneThisObject(WL_STATE.tabs[groupName]);

		//set all the tabs to false.
		for (var t = 0; t < newTabGroup.tabs.length; t++) {
			//tab array item to false
			newTabGroup.tabs[t].active = false;
			//and it's named counterpart
			newTabGroup[newTabGroup.tabs[t].name] = false;
		}

		//set the tempTab to true
		newTabGroup.tempTab.active = true;	

		eventManager.fire('tab_opened', newTabGroup.tempTab);

		//and apply to state!
		WL_STATE.tabs[groupName] = newTabGroup;
	},

	closeTab: function(groupName, tabName){
		console.log('closing tab');
		//clone the tab group state
		var newTabGroup = objectHelpers.cloneThisObject(WL_STATE.tabs[groupName]);

		//we may have to move them to a new tab, that's what this is for
		var newActiveTab = -1;

		//most probable situation - they're closing a tab that is currently open
		if (newTabGroup[tabName]) {
			//yep, they are. We're going to have to move them to another tab
			console.log('closing active tab');
			//case 1 - there's only one tab left open and that's the one they're closing
			if (newTabGroup.tabs.length == 1 ) {

			}

			//case 2 - they're on the last tab of the array, and that's the one we're closing
			if (newTabGroup.tabs[newTabGroup.tabs.lenght - 1].name == tabName) {

			}

			//default case - thay're on any tab that has another further along in the array
		} else {
			//nope, I guess they're just tidying up! Easy case
			console.log('closing non active tab', tabName);
			//find the tab to close in the array
			for (var t = 0; t < newTabGroup.tabs.length; t++) {
				if (newTabGroup.tabs[t].name == tabName){
					//splice it out that tabs array
					newTabGroup.tabs.splice(t, 1);
					//delete the named property
					delete newTabGroup[tabName];
				}
			}
		}

		//and apply to state!
		WL_STATE.tabs[groupName] = newTabGroup;
	},

	closeTempTab: function(groupName){
		console.log('closing temp tab');
	}
};